▼  The Racket Guide
 1  Welcome to Racket
 2  Racket Essentials
 3  Built-In Datatypes
 4  Expressions and Definitions
 5  Programmer-Defined Datatypes
 6  Modules
 7  Contracts
 8  Input and Output
 9  Regular Expressions
10  Exceptions and Control
11  Iterations and Comprehensions
12  Pattern Matching
13  Classes and Objects
14  Units (Components)
15  Reflection and Dynamic Evaluation
16  Macros
17  Creating Languages
18  Performance
19  Running and Creating Executables
20  Compilation and Configuration
21  More Libraries
22  Dialects of Racket and Scheme
    Bibliography
    Index
[...search manuals...]
  top← prev  up  next → 

Index

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

 

#!
.bat
.zo
3m
A Customer-Manager Component
A Dictionary
A Note to Readers with Lisp/Scheme Experience
A Parameteric (Simple) Stack
A Queue
Abbreviating quote with ’
aborts
Abstract Contracts using #:exists and #:∃
accessor
Adding Contracts to Signatures
Adding Contracts to Units
Additional Examples
Alternation
An Aside on Indenting Code
An Extended Example
And More
Anonymous Functions with lambda
any and any/c
Argument and Result Dependencies
Arity-Sensitive Functions: case-lambda
arms
assertions
Assignment and Redefinition
Assignment: set!
attached
backreference
Backreferences
Backtracking
backtracking
Basic Assertions
benchmarking
Booleans
box
Boxes
bracketed character class
Built-In Datatypes
byte
byte string
Bytes and Byte Strings
Bytes, Characters, and Encodings
call-by-reference
CGC
Chaining Tests: cond
character
character class
Characters
Characters and Character Classes
Checking Properties of Data Structures
Checking State Changes
Class Contracts
Classes and Objects
cloister
Cloisters
closures
Clustering
Clusters
code inspectors
collections
Combining Tests: and and or
Compilation and Configuration
Compile and Run-Time Phases
complex
components
composable continuations
Conditionals
Conditionals with if, and, or, and cond
conservative garbage collector
constructor
constructor guard
continuation
Continuations
contract combinator
Contract Messages with “???”
Contract Violations
Contracts
Contracts and Boundaries
Contracts and eq?
Contracts for case-lambda
Contracts for Units
Contracts on Functions in General
Contracts on Higher-order Functions
Contracts on Structures
Contracts: A Thorough Example
Controlling the Scope of External Names
Copying and Update
Creating and Installing Namespaces
Creating Executables
Creating Languages
Creating Stand-Alone Executables
current continuation
current namespace
Curried Function Shorthand
Datatypes and Serialization
Declaring a Rest Argument
Declaring Keyword Arguments
Declaring Optional Arguments
Default Ports
default prompt tag
define-syntax and syntax-rules
define-syntax-rule
Defining new #lang Languages
Defining Recursive Contracts
Definitions
Definitions and Interactions
definitions area
Definitions: define
delimited continuations
Designating a #lang Language
destructing bind
Dialects of Racket and Scheme
disarm
domain
dye pack
Dynamic Binding: parameterize
Effects After: begin0
Effects Before: begin
Effects If...: when and unless
eval
Evaluation Order and Arity
exception
Exceptions
Exceptions and Control
Exists Contracts and Predicates
expander
expands
Experimenting with Contracts and Modules
Exports: provide
Expressions and Definitions
Extended Example: Call-by-Reference Functions
External Class Contracts
Final, Augment, and Inner
First-Class Units
Fixed but Statically Unknown Arities
fixnum
Fixnum and Flonum Optimizations
flat named contracts
flonum
for and for*
for/and and for/or
for/first and for/last
for/fold and for*/fold
for/list and for*/list
for/vector and for*/vector
Function Calls (Procedure Applications)
Function Calls (Procedure Applications)
Function Calls, Again
Function Shorthand
Function-Call Optimizations
functional update
Functions (Procedures): lambda
General Macro Transformers
generational garbage collector
Gotchas
Graphics and GUIs
greedy
Guarantees for a Specific Value
Guarantees for All Values
Guidelines for Using Assignment
hash table
Hash Tables
I/O Patterns
identifier macro
Identifier Macros
identifier syntax object
Identifiers
Identifiers and Binding
Implicit Form Bindings
Imports: require
index pairs
Inherit and Super in Traits
Initialization Arguments
Input and Output
Installing a Language
instantiates
integer
Interacting with Racket
Interactive Mode
Interfaces
Internal and External Names
Internal Class Contracts
Internal Definitions
invoked
Invoking Units
Iteration Performance
Iterations and Comprehensions
JIT
just-in-time
keyword
Keyword Arguments
Keyword Arguments
Keywords
letrec Performance
Lexical Scope
link
Linking Units
list
List Iteration from Scratch
Lists and Racket Syntax
Lists, Iteration, and Recursion
Load Mode
Local Binding
Local Binding with define, let, and let*
Local Scopes
Lookahead
Lookbehind
Looking Ahead and Behind
macro
macro pattern variables
macro transformer
macro-generating macro
Macro-Generating Macros
Macros
Manipulating Namespaces
Matching Regexp Patterns
Matching Sequences
Memory Management
meta-compile phase level
metacharacters
metasequences
Methods
mixin
Mixing Patterns and Expressions: syntax-case
Mixing set! and provide/contract
Mixins
Mixins and Interfaces
Module Basics
module language
Module Languages
Module Mode
module path
Module Paths
Module Syntax
Module-Handling Configuration
Modules
Modules and Performance
More Libraries
More Rackets
More Structure Type Options
multi-line mode
Multiple Result Values
Multiple Values and define-values
Multiple Values: let-values, let*-values, letrec-values
Multiple Values: set!-values
Multiple-Valued Sequences
mutable pair
Mutation and Performance
mutator
Named let
namespace
Namespaces
Namespaces and Modules
non-capturing
Non-capturing Clusters
non-greedy
Notation
number
Numbers
opaque
Opaque versus Transparent Structure Types
Optional Arguments
Optional Keyword Arguments
pair
Pairs and Lists
Pairs, Lists, and Racket Syntax
Parallel Binding: let
Parallelism with Futures
parameter
Parameterized Mixins
Pattern Matching
pattern variables
pattern-based macro
Pattern-Based Macros
Performance
Performance in DrRacket
phase level -1
phase level 2
port
POSIX character class
POSIX character classes
Predefined List Loops
predicate
prefab
Prefab Structure Types
Programmer-Defined Datatypes
prompt
prompt tag
Prompts and Aborts
property
protected
Protected Exports
protected method
Quantifiers
quantifiers
Quasiquoting: quasiquote and `
Quoting Pairs and Symbols with quote
Quoting: quote and ’
R5RS
R6RS
Racket Essentials
racket/exists
range
rational
reader
Reader Extensions
Reading and Writing Racket Data
readtable
Readtables
real
Recursion versus Iteration
Recursive Binding: letrec
Reflection and Dynamic Evaluation
regexp
Regular Expressions
REPL
Rest Arguments
Rolling Your Own Contracts
Running and Creating Executables
Running racket and gracket
S-expression
Scripting Evaluation and Using load
Scripts
Sequence Constructors
Sequencing
Sequential Binding: let*
serialization
Sharing Data and Code Across Namespaces
signatures
Signatures and Units
Simple Branching: if
Simple Contracts on Functions
Simple Definitions and Expressions
Simple Dispatch: case
Simple Structure Types: struct
Simple Values
Some Frequently Used Character Classes
Source Locations
Source-Handling Configuration
speed
Standards
string
Strings (Unicode)
Structure Comparisons
Structure Subtypes
structure type descriptor
Structure Type Generativity
Styles of ->
subcluster
submatch
subpattern
symbol
Symbols
Syntax Objects
syntax objects
Syntax Taints
tail position
Tail Recursion
tainted
Tainting Modes
Taints and Code Inspectors
Teaching
template
template phase level
text string
The #lang Shorthand
The apply Function
The Bytecode and Just-in-Time (JIT) Compilers
The mixin Form
The module Form
The Racket Guide
The trait Form
The Web Server
Traits
Traits as Sets of Mixins
transformer
transformer binding
transparent
Unchecked, Unsafe Operations
unit versus module
Units
Units (Components)
Unix Scripts
Using #lang reader
Using #lang s-exp
Using #lang s-exp syntax/module-reader
Using Foreign Libraries
Varieties of Ports
vector
Vectors
Void and Undefined
Welcome to Racket
Whole-module Signatures and Units
Windows Batch Files
with-syntax and generate-temporaries
Writing Regexp Patterns

[...search manuals...]
  top← prev  up  next → 
 
