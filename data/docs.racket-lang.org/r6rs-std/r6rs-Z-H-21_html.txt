                        [Go to first, previous, next page;   contents;   index]

 

References

 [1] J. W. Backus, F.L. Bauer, J.Green, C. Katz, J. McCarthy P. Naur, A. J.
     Perlis, H. Rutishauser, K. Samuelson, B. Vauquois J. H. Wegstein, A. van
     Wijngaarden, and M. Woodger. Revised report on the algorithmic language
     Algol 60. Communications of the ACM, 6(1):1–17, 1963.

 [2] Alan Bawden and Jonathan Rees. Syntactic closures. In ACM Conference on
     Lisp and Functional Programming, pages 86–95, Snowbird, Utah, 1988. ACM
     Press.

 [3] Scott Bradner. Key words for use in RFCs to indicate requirement levels.
     http://www.ietf.org/rfc/rfc2119.txt, March 1997. RFC 2119.

 [4] Robert G. Burger and R. Kent Dybvig. Printing floating-point numbers
     quickly and accurately. In Proc. of the ACM SIGPLAN ’96 Conference on
     Programming Language Design and Implementation, pages 108–116,
     Philadelphia, PA, USA, May 1996. ACM Press.

 [5] William Clinger. Proper tail recursion and space efficiency. In Keith
     Cooper, editor, Proceedings of the 1998 Conference on Programming Language
     Design and Implementation, pages 174–185, Montreal, Canada, June 1998. ACM
     Press. Volume 33(5) of SIGPLAN Notices.

 [6] William Clinger and Jonathan Rees. Macros that work. In Proc.  1991 ACM
     SIGPLAN Symposium on Principles of Programming Languages, pages 155–162,
     Orlando, Florida, January 1991. ACM Press.

 [7] William D. Clinger. How to read floating point numbers accurately. In
     Proc. Conference on Programming Language Design and Implementation ’90,
     pages 92–101, White Plains, New York, USA, June 1990. ACM.

 [8] R. Kent Dybvig. Chez Scheme Version 7 User’s Guide. Cadence Research
     Systems, 2005. http://www.scheme.com/csug7/.

 [9] R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. Syntactic abstraction in
     Scheme. Lisp and Symbolic Computation, 1(1):53–75, 1988.

[10] Matthias Felleisen and Matthew Flatt. Programming languages and lambda
     calculi. http://www.cs.utah.edu/plt/publications/pllc.pdf, 2003.

[11] Matthew Flatt. PLT MzScheme: Language Manual. Rice University, University
     of Utah, July 2006. http://download.plt-scheme.org/doc/352/html/mzscheme/.

[12] Daniel P. Friedman, Christopher Haynes, Eugene Kohlbecker, and Mitchell
     Wand. Scheme 84 interim reference manual. Indiana University, January
     1985. Indiana University Computer Science Technical Report 153.

[13] IEEE standard 754-1985. IEEE standard for binary floating-point
     arithmetic, 1985. Reprinted in SIGPLAN Notices, 22(2):9-25, 1987.

[14] Richard Kelsey, William Clinger, and Jonathan Rees. Revised^5 report on
     the algorithmic language Scheme. Higher-Order and Symbolic Computation, 11
     (1):7–105, 1998.

[15] Eugene E. Kohlbecker, Daniel P. Friedman, Matthias Felleisen, and Bruce
     Duba. Hygienic macro expansion. In Proceedings of the 1986 ACM Conference
     on Lisp and Functional Programming, pages 151–161, 1986.

[16] Eugene E. Kohlbecker Jr. Syntactic Extensions in the Programming Language
     Lisp. PhD thesis, Indiana University, August 1986.

[17] Jacob Matthews and Robert Bruce Findler. An operational semantics for R5RS
     Scheme. In J. Michael Ashley and Michael Sperber, editors, Proceedings of
     the Sixth Workshop on Scheme and Functional Programming, pages 41–54,
     Tallin, Estonia, September 2005. Indiana University Technical Report
     TR619.

[18] Jacob Matthews and Robert Bruce Findler. An operational semantics for
     Scheme. Journal of Functional Programming, 2007. From http://
     www.cambridge.org/journals/JFP/.

[19] Jacob Matthews, Robert Bruce Findler, Matthew Flatt, and Matthias
     Felleisen. A visual environment for developing context-sensitive term
     rewriting systems. In Proc. 15th Conference on Rewriting Techniques and
     Applications, Aachen, June 2004. Springer-Verlag.

[20] MIT Department of Electrical Engineering and Computer Science. Scheme
     manual, seventh edition, September 1984.

[21] Jonathan A. Rees, Norman I. Adams IV, and James R. Meehan. The T manual.
     Yale University Computer Science Department, fourth edition, January 1984.

[22] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten.
     Revised^6 report on the algorithmic language Scheme (Non-Normative
     appendices). http://www.r6rs.org/, 2007.

[23] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten.
     Revised^6 report on the algorithmic language Scheme (Rationale). http://
     www.r6rs.org/, 2007.

[24] Michael Sperber, R. Kent Dybvig, Matthew Flatt, Anton van Straaten,
     Richard Kelsey, William Clinger, and Jonathan Rees. Revised^6 report on
     the algorithmic language Scheme (Libraries). http://www.r6rs.org/, 2007.

[25] Guy Lewis Steele Jr. Common Lisp: The Language. Digital Press, Burlington,
     MA, second edition, 1990.

[26] Texas Instruments, Inc. TI Scheme Language Reference Manual, November
     1985. Preliminary version 1.0.

[27] The Unicode Consortium. The Unicode standard, version 5.0.0. defined by:
     The Unicode Standard, Version 5.0 (Boston, MA, Addison-Wesley, 2007. ISBN
     0-321-48091-0), 2007.

[28] William M. Waite and Gerhard Goos. Compiler Construction. Springer-Verlag,
     1984.

[29] Andrew Wright and Matthias Felleisen. A syntactic approach to type
     soundness. Information and Computation, 115(1):38–94, 1994. First appeared
     as Technical Report TR160, Rice University, 1991.

 

Index

     Alphabetic index of definitions of concepts, keywords, and procedures

#,@ 7 #\ 7ii #| 7iii & 9 ’ 7iv #’ 7v * 14 * (formal semantics) 15, 15ii + 14ii
+ (formal semantics) 15iii, 15iv ,@ 7vi , 7vii #, 7viii - 14iii, 14iv - (formal
semantics) 15v, 15vi, 15vii -0.0 6 ... 14v, 14vi / 14vii, 14viii / (formal
semantics) 15viii, 15ix, 15x, 15xi ; 7ix #; 7x < 14ix <= 14x = 14xi => 14xii >
14xiii >= 14xiv _ 14xv, 14xvi #‘ 7xi ‘ 7xii |# 7xiii

abs 14xvii acos 14xviii and 14xix angle 14xx append 14xxi apply 14xxii apply
(formal semantics) 15xii, 15xiii, 15xiv, 15xv, 15xvi, 15xvii, 15xviii argument
checking 8 asin 14xxiii assert 14xxiv assertion-violation 14xxv assignment 4
atan 14xxvi, 14xxvii

#b 7xiv, 7xv backquote 14xxviii begin 14xxix, 14xxx begin (formal semantics)
15xix, 15xx, 15xxi begin0 (formal semantics) 15xxii, 15xxiii, 15xxiv, 15xxv,
15xxvi binding 4ii, 8ii binding construct 8iii body 14xxxi boolean 4iii boolean
=? 14xxxii boolean? 14xxxiii, 14xxxiv bound 8iv

caar 14xxxv cadr 14xxxvi call 12 call-with-current-continuation 14xxxvii
call-with-values 14xxxviii call-with-values (formal semantics) 15xxvii,
15xxviii call/cc 14xxxix call/cc (formal semantics) 15xxix car 14xl car (formal
semantics) 15xxx, 15xxxi case 14xli cdddar 14xlii cddddr 14xliii cdr 14xliv cdr
(formal semantics) 15xxxii, 15xxxiii ceiling 14xlv char->integer 14xlvi char<=?
14xlvii char<? 14xlviii char=? 14xlix char>=? 14l char>? 14li char? 14lii,
14liii character 4iv Characters 14liv code point 14lv comment 7xvi, 7xvii
complex? 14lvi cond 14lvii condition? (formal semantics) 15xxxiv, 15xxxv cons
14lviii cons (formal semantics) 15xxxvi consi (formal semantics) 15xxxvii
constant 8v continuable exception 8vi continuation 4v core form 13 cos 14lix

#d 7xviii datum 7xix, 7xx datum value 4vi, 7xxi define 14lx, 14lxi
define-syntax 14lxii definition 4vii, 8vii, 10, 14lxiii, 14lxiv, 14lxv
denominator 14lxvi derived form 4viii div 14lxvii div-and-mod 14lxviii div0
14lxix div0-and-mod0 14lxx dot (formal semantics) 15xxxviii, 15xxxix dw (formal
semantics) 15xl, 15xli dynamic environment 8viii dynamic extent 8ix
dynamic-wind 14lxxi dynamic-wind (formal semantics) 15xlii, 15xliii, 15xliv

#e 7xxii, 7xxiii else 14lxxii, 14lxxiii empty list 7xxiv, 14lxxiv, 14lxxv,
14lxxvi, 14lxxvii, 14lxxviii eq? 14lxxix equal? 14lxxx equivalence predicate
14lxxxi eqv? 14lxxxii eqv? (formal semantics) 15xlv, 15xlvi, 15xlvii, 15xlviii,
15xlix error 14lxxxiii escape procedure 4ix, 14lxxxiv escape sequence 7xxv
even? 14lxxxv exact 6ii, 14lxxxvi exact 14lxxxvii exact-integer-sqrt 14lxxxviii
exact? 14lxxxix exactness 6iii exceptional situation 8x exp 14xc export 10ii
expression 4x, 10iii expt 14xci external representation 7xxvi

#f 7xxvii, 14xcii false 8xi finite? 14xciii fixnum 6iv flonum 6v floor 14xciv
for-each 14xcv form 4xi, 7xxviii

gcd 14xcvi

hole 15l hygienic 12ii

#i 7xxix, 7xxx identifier 4xii, 7xxxi, 7xxxii, 8xii identifier-syntax 14xcvii
if 14xcviii, 14xcix if (formal semantics) 15li, 15lii imag-part 14c immutable
8xiii implementation restriction 6vi, 8xiv import 10iv import level 10v
improper list 14ci inexact 6vii, 14cii inexact 14ciii inexact? 14civ infinite?
14cv infinity 6viii instance 10vi instantiation 10vii integer object 6ix
integer->char 14cvi integer-valued? 14cvii integer? 14cviii

keyword 8xv, 12iii

lambda 14cix lambda (formal semantics) 15liii, 15liv, 15lv, 15lvi, 15lvii,
15lviii, 15lix, 15lx lcm 14cx length 14cxi let 14cxii, 14cxiii let* 14cxiv
let*-values 14cxv let-syntax 14cxvi let-values 14cxvii letrec 14cxviii letrec
(formal semantics) 15lxi letrec* 14cxix letrec* (formal semantics) 15lxii
letrec-syntax 14cxx level 10viii lexeme 7xxxiii library 4xiii, 8xvi, 10ix
library 10x list 4xiv list 14cxxi list (formal semantics) 15lxiii, 15lxiv
list->string 14cxxii list->vector 14cxxiii list-ref 14cxxiv list-tail 14cxxv
list? 14cxxvi literal 12iv location 8xvii log 14cxxvii, 14cxxviii

macro 4xv, 12v macro keyword 12vi macro transformer 12vii, 14cxxix macro use
12viii magnitude 14cxxx make-polar 14cxxxi make-rectangular 14cxxxii
make-string 14cxxxiii, 14cxxxiv make-vector 14cxxxv, 14cxxxvi map 14cxxxvii max
14cxxxviii may 5 min 14cxxxix mod 14cxl mod0 14cxli must 5ii must be 9ii must
not 5iii mutable 8xviii

NaN 6x nan? 14cxlii negative infinity 6xi negative? 14cxliii not 14cxliv null
(formal semantics) 15lxv, 15lxvi null? 14cxlv, 14cxlvi null? (formal semantics)
15lxvii, 15lxviii number 4xvi, 6xii number->string 14cxlvii, 14cxlviii, 14cxlix
number? 14cl, 14cli numerator 14clii numerical types 6xiii

#o 7xxxiv, 7xxxv object 4xvii odd? 14cliii or 14cliv

pair 4xviii, 14clv pair? 14clvi, 14clvii pair? (formal semantics) 15lxix, 15lxx
pattern variable 14clviii phase 10xi positive infinity 6xiv positive? 14clix
predicate 14clx prefix notation 4xix procedure 4xx, 4xxi procedure call 4xxii,
12ix procedure? 14clxi, 14clxii procedure? (formal semantics) 15lxxi, 15lxxii
proper tail recursion 8xix

quasiquote 14clxiii quote 14clxiv

raise 8xx raise (formal semantics) 15lxxiii raise-continuable (formal
semantics) 15lxxiv rational-valued? 14clxv rational? 14clxvi rationalize
14clxvii real-part 14clxviii real-valued? 14clxix real? 14clxx referentially
transparent 12x region 8xxi, 14clxxi, 14clxxii, 14clxxiii, 14clxxiv, 14clxxv,
14clxxvi, 14clxxvii, 14clxxviii responsibility 8xxii reverse 14clxxix (rnrs
base (6)) 14clxxx round 14clxxxi

safe libraries 8xxiii scalar value 14clxxxii, 14clxxxiii set! 14clxxxiv set!
(formal semantics) 15lxxv, 15lxxvi, 15lxxvii set-car! (formal semantics)
15lxxviii, 15lxxix set-cdr! (formal semantics) 15lxxx, 15lxxxi should 5iv
should not 5v simplest rational 14clxxxv sin 14clxxxvi special form 4xxiii
splicing 14clxxxvii sqrt 14clxxxviii standard library 8xxiv string 4xxiv string
14clxxxix string->list 14cxc string->number 14cxci, 14cxcii string->symbol
14cxciii string-append 14cxciv string-copy 14cxcv string-for-each 14cxcvi
string-length 14cxcvii string-ref 14cxcviii string<=? 14cxcix string<? 14cc
string=? 14cci string>=? 14ccii string>? 14cciii string? 14cciv, 14ccv subform
4xxv, 7xxxvi substring 14ccvi surrogate 14ccvii symbol 4xxvi, 7xxxvii symbol->
string 14ccviii symbol=? 14ccix symbol? 14ccx, 14ccxi syntactic abstraction
12xi syntactic datum 4xxvii, 7xxxviii, 7xxxix syntactic keyword 4xxviii, 7xl,
8xxv, 12xii syntax violation 8xxvi syntax-rules 14ccxii

#t 7xli, 14ccxiii tail call 8xxvii, 14ccxiv tail context 8xxviii tan 14ccxv
throw (formal semantics) 15lxxxii top-level program 4xxix, 8xxix, 11
transformer 12xiii, 14ccxvi true 8xxx, 14ccxvii, 14ccxviii truncate 14ccxix
type 14ccxx

unbound 8xxxi, 12xiv Unicode 14ccxxi Unicode scalar value 14ccxxii unquote
14ccxxiii unquote-splicing 14ccxxiv unspecified behavior 8xxxii unspecified
values 8xxxiii

valid indices 14ccxxv, 14ccxxvi values 14ccxxvii values (formal semantics)
15lxxxiii, 15lxxxiv, 15lxxxv, 15lxxxvi, 15lxxxvii, 15lxxxviii, 15lxxxix, 15xc,
15xci variable 4xxx, 7xlii, 8xxxiv, 12xv vector 4xxxi vector 14ccxxviii
vector->list 14ccxxix vector-fill! 14ccxxx vector-for-each 14ccxxxi
vector-length 14ccxxxii vector-map 14ccxxxiii vector-ref 14ccxxxiv vector-set!
14ccxxxv vector? 14ccxxxvi, 14ccxxxvii visit 10xii visiting 10xiii

Whitespace 7xliii with-exception-handler (formal semantics) 15xcii, 15xciii,
15xciv, 15xcv

#x 7xliv, 7xlv

zero? 14ccxxxviii

                        [Go to first, previous, next page;   contents;   index]

