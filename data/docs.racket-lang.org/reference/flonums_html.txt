►  The Racket Reference
 1  Language Model
 2  Syntactic Forms
 3  Datatypes
 4  Structures
 5  Classes and Objects
 6  Units
 7  Contracts
 8  Pattern Matching
 9  Control Flow
10  Concurrency and Parallelism
11  Macros
12  Input and Output
13  Reflection and Security
14  Operating System
15  Memory Management
16  Unsafe Operations
17  Running Racket
    Bibliography
    Index
► 3  Datatypes
 3.1  Booleans and Equality
 3.2  Numbers
 3.3  Strings
 3.4  Byte Strings
 3.5  Characters
 3.6  Symbols
 3.7  Regular Expressions
 3.8  Keywords
 3.9  Pairs and Lists
3.10  Mutable Pairs and Lists
3.11  Vectors
3.12  Boxes
3.13  Hash Tables
3.14  Sequences and Streams
3.15  Dictionaries
3.16  Sets
3.17  Procedures
3.18  Void and Undefined
▼ 3.2  Numbers
3.2.1  Number Types
3.2.2  Generic Numerics
3.2.3  Flonums
3.2.4  Fixnums
► 3.2.3  Flonums
3.2.3.1  Flonum Arithmetic
3.2.3.2  Flonum Vectors
On this page:
3.2.3.1 Flonum Arithmetic
fl+
fl-
fl*
fl/
flabs
fl=
fl<
fl>
fl<=
fl>=
flmin
flmax
flround
flfloor
flceiling
fltruncate
flsin
flcos
fltan
flasin
flacos
flatan
fllog
flexp
flsqrt
->fl
fl->exact-integer
make-flrectangular
flreal-part
flimag-part
3.2.3.2 Flonum Vectors
flvector?
flvector
make-flvector
flvector-length
flvector-ref
flvector-set!
flvector-copy
in-flvector
for/ flvector
for*/ flvector
shared-flvector
make-shared-flvector
[...search manuals...]
  top← prev  up  next → 

3.2.3 Flonums

 (require racket/flonum)

The racket/flonum library provides operations like fl+ that consume and produce
only flonums. Flonum-specific operations can provide better performance when
used consistently, and they are as safe as generic operations like +.

            +See also Fixnum and Flonum Optimizations in The Racket Guide.

3.2.3.1 Flonum Arithmetic

(fl+ a b) → flonum?
  a : flonum?
  b : flonum?
(fl- a b) → flonum?
  a : flonum?
  b : flonum?
(fl* a b) → flonum?
  a : flonum?
  b : flonum?
(fl/ a b) → flonum?
  a : flonum?
  b : flonum?
(flabs a) → flonum?
  a : flonum?
Like +, -, *, /, and abs, but constrained to consume flonums. The result is
always a flonum.

(fl= a b) → boolean?
  a : flonum?
  b : flonum?
(fl< a b) → boolean?
  a : flonum?
  b : flonum?
(fl> a b) → boolean?
  a : flonum?
  b : flonum?
(fl<= a b) → boolean?
  a : flonum?
  b : flonum?
(fl>= a b) → boolean?
  a : flonum?
  b : flonum?
(flmin a b) → flonum?
  a : flonum?
  b : flonum?
(flmax a b) → flonum?
  a : flonum?
  b : flonum?
Like =, <, >, <=, >=, min, and max, but constrained to consume flonums.

(flround a) → flonum?
  a : flonum?
(flfloor a) → flonum?
  a : flonum?
(flceiling a) → flonum?
  a : flonum?
(fltruncate a) → flonum?
  a : flonum?
Like round, floor, ceiling, and truncate, but constrained to consume flonums.

(flsin a) → flonum?
  a : flonum?
(flcos a) → flonum?
  a : flonum?
(fltan a) → flonum?
  a : flonum?
(flasin a) → flonum?
  a : flonum?
(flacos a) → flonum?
  a : flonum?
(flatan a) → flonum?
  a : flonum?
(fllog a) → flonum?
  a : flonum?
(flexp a) → flonum?
  a : flonum?
(flsqrt a) → flonum?
  a : flonum?
Like sin, cos, tan, asin, acos, atan, log, exp, and sqrt, but constrained to
consume and produce flonums. The result is +nan.0 when a number outside the
range -1.0 to 1.0 is given to flasin or flacos, or when a negative number is
given to fllog or flsqrt.

(->fl a) → flonum?
  a : exact-integer?
Like exact->inexact, but constrained to consume exact integers, so the result
is always a flonum.

(fl->exact-integer a) → exact-integer?
  a : flonum?
Like inexact->exact, but constrained to consume an integer flonum, so the
result is always an exact integer.

(make-flrectangular a b)
 → (and/c complex? inexact? (not/c real?))
  a : flonum?
  b : flonum?
(flreal-part a) → flonum?
  a : (and/c complex? inexact? (not/c real?))
(flimag-part a) → flonum?
  a : (and/c complex? inexact? (not/c real?))
Like make-rectangular, real-part, and imag-part, but both parts of the complex
number must be inexact.

3.2.3.2 Flonum Vectors

A flvector is like a vector, but it holds only inexact real numbers. This
representation can be more compact, and unsafe operations on flvectors (see
racket/unsafe/ops) can execute more efficiently than unsafe operations on
vectors of inexact reals.

An f64vector as provided by ffi/vector stores the same kinds of values as a
flvector, but with extra indirections that make f64vectors more convenient for
working with foreign libraries. The lack of indirections makes unsafe flvector
access more efficient.

Two flvectors are equal? if they have the same length, and if the values in
corresponding slots of the flvectors are equal?.

(flvector? v) → boolean?
  v : any/c
Returns #t if v is a flvector, #f otherwise.

(flvector x ...) → flvector?
  x : flonum?
Creates a flvector containing the given inexact real numbers.

Example:

    > (flvector 2.0 3.0 4.0 5.0)
    #<flvector>



(make-flvector size [x]) → flvector?
  size : exact-nonnegative-integer?
  x : flonum? = 0.0
Creates a flvector with size elements, where every slot in the flvector is
filled with x.

Example:

    > (make-flvector 4 3.0)
    #<flvector>



(flvector-length vec) → exact-nonnegative-integer?
  vec : flvector?
Returns the length of vec (i.e., the number of slots in the flvector).

(flvector-ref vec pos) → flonum?
  vec : flvector?
  pos : exact-nonnegative-integer?
Returns the inexact real number in slot pos of vec. The first slot is position
0, and the last slot is one less than (flvector-length vec).

(flvector-set! vec pos x) → flonum?
  vec : flvector?
  pos : exact-nonnegative-integer?
  x : flonum?
Sets the inexact real number in slot pos of vec. The first slot is position 0,
and the last slot is one less than (flvector-length vec).

(flvector-copy vec [start end]) → flvector?
  vec : flvector?
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (vector-length v)
Creates a fresh flvector of size (- end start), with all of the elements of vec
from start (inclusive) to end (exclusive).

(in-flvector vec [start stop step]) → sequence?
  vec : flvector?
  start : exact-nonnegative-integer? = 0
  stop : (or/c exact-integer? #f) = #f
  step : (and/c exact-integer? (not/c zero?)) = 1
Returns a sequence equivalent to vec when no optional arguments are supplied.

The optional arguments start, stop, and step are as in in-vector.

A in-flvector application can provide better performance for flvector iteration
when it appears directly in a for clause.

(for/flvector (for-clause ...) body ...)
(for/flvector #:length length-expr (for-clause ...) body ...)
(for*/flvector (for-clause ...) body ...)
(for*/flvector #:length length-expr (for-clause ...) body ...)
Like for/vector or for*/vector, but for flvectors.

(shared-flvector x ...) → flvector?
  x : flonum?
Creates a flvector containing the given inexact real numbers. When places are
enabled, the new flvector is allocated in the shared memory space.

Example:

    > (shared-flvector 2.0 3.0 4.0 5.0)
    #<flvector>



(make-shared-flvector size [x]) → flvector?
  size : exact-nonnegative-integer?
  x : flonum? = 0.0
Creates a flvector with size elements, where every slot in the flvector is
filled with x. When places are enabled, the new flvector is allocated in the
shared memory space.

Example:

    > (make-shared-flvector 4 3.0)
    #<flvector>



[...search manuals...]
  top← prev  up  next → 
 
