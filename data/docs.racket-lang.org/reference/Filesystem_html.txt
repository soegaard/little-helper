►  The Racket Reference
 1  Language Model
 2  Syntactic Forms
 3  Datatypes
 4  Structures
 5  Classes and Objects
 6  Units
 7  Contracts
 8  Pattern Matching
 9  Control Flow
10  Concurrency and Parallelism
11  Macros
12  Input and Output
13  Reflection and Security
14  Operating System
15  Memory Management
16  Unsafe Operations
17  Running Racket
    Bibliography
    Index
▼ 14  Operating System
14.1  Paths
14.2  Filesystem
14.3  Networking
14.4  Processes
14.5  Logging
14.6  Time
14.7  Environment and Runtime Information
14.8  Command-Line Parsing
► 14.2  Filesystem
14.2.1  Locating Paths
14.2.2  Files
14.2.3  Directories
14.2.4  Declaring Paths Needed at Run Time
14.2.5  More File and Directory Utilities
On this page:
14.2.1 Locating Paths
find-system-path
path-list-string->path-list
find-executable-path
14.2.2 Files
file-exists?
link-exists?
delete-file
rename-file-or-directory
file-or-directory-modify-seconds
file-or-directory-permissions
file-or-directory-identity
file-size
copy-file
make-file-or-directory-link
14.2.3 Directories
current-directory
current-drive
directory-exists?
make-directory
delete-directory
directory-list
filesystem-root-list
14.2.4 Declaring Paths Needed at Run Time
define-runtime-path
define-runtime-paths
define-runtime-path-list
define-runtime-module-path-index
define-runtime-module-path
runtime-paths
14.2.5 More File and Directory Utilities
file->string
file->bytes
file->value
file->list
file->lines
file->bytes-lines
display-to-file
write-to-file
display-lines-to-file
copy-directory/ files
delete-directory/ files
find-files
pathlist-closure
fold-files
make-directory*
make-temporary-file
get-preference
put-preferences
preferences-lock-file-mode
make-handle-get-preference-locked
call-with-file-lock/ timeout
make-lock-file-name
user-read-bit
user-write-bit
user-execute-bit
group-read-bit
group-write-bit
group-execute-bit
other-read-bit
other-write-bit
other-execute-bit
[...search manuals...]
  top← prev  up  next → 

14.2 Filesystem

14.2.1 Locating Paths

(find-system-path kind) → path?
  kind : symbol?
Returns a machine-specific path for a standard type of path specified by kind,
which must be one of the following:

  • 'home-dir — the current user’s home directory.

    On Unix and Mac OS X, this directory is determined by expanding the path
    "~", which is expanded by first checking for a HOME environment variable.
    If none is defined, the USER and LOGNAME environment variables are
    consulted (in that order) to find a user name, and then system files are
    consulted to locate the user’s home directory.

    On Windows, the user’s home directory is the user-specific profile
    directory as determined by the Windows registry. If the registry cannot
    provide a directory for some reason, the value of the USERPROFILE
    environment variable is used instead, as long as it refers to a directory
    that exists. If USERPROFILE also fails, the directory is the one specified
    by the HOMEDRIVE and HOMEPATH environment variables. If those environment
    variables are not defined, or if the indicated directory still does not
    exist, the directory containing the current executable is used as the home
    directory.

  • 'pref-dir — the standard directory for storing the current user’s
    preferences. On Unix, the directory is ".racket" in the user’s home
    directory. On Windows, it is "Racket" in the user’s application-data folder
    as specified by the Windows registry; the application-data folder is
    usually "Application Data" in the user’s profile directory. On Mac OS X, it
    is "Library/Preferences" in the user’s home directory. This directory might
    not exist.

  • 'pref-file — a file that contains a symbol-keyed association list of
    preference values. The file’s directory path always matches the result
    returned for 'pref-dir. The file name is "racket-prefs.rktd" on Unix and
    Windows, and it is "org.racket-lang.prefs.rktd" on Mac OS X. The file’s
    directory might not exist. See also get-preference.

  • 'temp-dir — the standard directory for storing temporary files. On Unix and
    Mac OS X, this is the directory specified by the TMPDIR environment
    variable, if it is defined, otherwise it is the first path that exists
    among "/var/tmp", "/usr/tmp", and "/tmp". On Windows, the result is the
    directory specified by the TMP or TEMP environment variable, if it is
    defined, otherwise it is the current directory.

  • 'init-dir — the directory containing the initialization file used by the
    Racket executable. It is the same as the current user’s home directory.

  • 'init-file — the file loaded at start-up by the Racket executable. The
    directory part of the path is the same path as returned for 'init-dir. The
    file name is platform-specific:

      □ Unix and Mac OS X: ".racketrc"

      □ Windows: "racketrc.rktl"

  • 'addon-dir — a directory for installing Racket extensions. This directory
    is specified by the PLTADDONDIR environment variable, and it can be
    overridden by the --addon or -A command-line flag. If no environment
    variable or flag is specified, or if the value is not a legal path name,
    then this directory defaults to "Library/Racket" in the user’s home
    directory on Mac OS X and 'pref-dir otherwise. This directory might not
    exist.

  • 'doc-dir — the standard directory for storing the current user’s documents.
    On Unix, it’s the same as 'home-dir. On Mac OS X, it’s the "Documents"
    directory in the user’s home directory. On Windows, it is the user’s
    documents folder as specified by the Windows registry; the documents folder
    is usually "My Documents" in the user’s home directory.

  • 'desk-dir — the directory for the current user’s desktop. On Unix, it’s the
    same as 'home-dir. On Windows, it is the user’s desktop folder as specified
    by the Windows registry; the documents folder is usually "Desktop" in the
    user’s home directory. On Mac OS X, it is the desktop directory, which is
    specifically "~/Desktop" on Mac OS X.

  • 'sys-dir — the directory containing the operating system for Windows. On
    Unix and Mac OS X, the result is "/".

  • 'exec-file — the path of the Racket executable as provided by the operating
    system for the current invocation. For some operating systems, the path can
    be relative.

                For GRacket, the executable path is the name of a GRacket
                executable.

  • 'run-file — the path of the current executable; this may be different from
    result for 'exec-file because an alternate path was provided through a
    --name or -N command-line flag to the Racket (or GRacket) executable, or
    because an embedding executable installed an alternate path. In particular
    a “launcher” script created by make-racket-launcher sets this path to the
    script’s path.

  • 'collects-dir — a path to the main collection of libraries (see Libraries
    and Collections). If this path is relative, then it is relative to the
    executable as reported by (find-system-path 'exec-file)—though the latter
    could be a soft-link or relative to the user’s executable search path, so
    that the two results should be combined with find-executable-path. The
    'collects-dir path is normally embedded in the Racket executable, but it
    can be overridden by the --collects or -X command-line flag.

  • 'orig-dir — the current directory at start-up, which can be useful in
    converting a relative-path result from (find-system-path 'exec-file) or (
    find-system-path 'run-file) to a complete path.

(path-list-string->path-list   str                 
                               default-path-list)  
 → (listof path?)
  str : (or/c string? bytes?)
  default-path-list : (listof path?)
Parses a string or byte string containing a list of paths, and returns a list
of path strings. On Unix and Mac OS X, paths in a path list are separated by a
:; on Windows, paths are separated by a ;, and all "s in the string are
discarded. Whenever the path list contains an empty path, the list
default-path-list is spliced into the returned list of paths. Parts of str that
do not form a valid path are not included in the returned list.

(find-executable-path    program-sub        
                       [ related-sub        
                         deepest?])    →   (or/c path? #f)
  program-sub : path-string?
  related-sub : (or/c path-string? #f) = #f
  deepest? : any/c = #f
Finds a path for the executable program-sub, returning #f if the path cannot be
found.

If related-sub is not #f, then it must be a relative path string, and the path
found for program-sub must be such that the file or directory related-sub
exists in the same directory as the executable. The result is then the full
path for the found related-sub, instead of the path for the executable.

This procedure is used by the Racket executable to find the standard library
collection directory (see Libraries and Collections). In this case, program is
the name used to start Racket and related is "collects". The related-sub
argument is used because, on Unix and Mac OS X, program-sub may involve to a
sequence of soft links; in this case, related-sub determines which link in the
chain is relevant.

If related-sub is not #f, then when find-executable-path does not finds a
program-sub that is a link to another file path, the search can continue with
the destination of the link. Further links are inspected until related-sub is
found or the end of the chain of links is reached. If deepest? is #f (the
default), then the result corresponds to the first path in a chain of links for
which related-sub is found (and further links are not actually explored);
otherwise, the result corresponds to the last link in the chain for which
related-sub is found.

If program-sub is a pathless name, find-executable-path gets the value of the 
PATH environment variable; if this environment variable is defined,
find-executable-path tries each path in PATH as a prefix for program-sub using
the search algorithm described above for path-containing program-subs. If the
PATH environment variable is not defined, program-sub is prefixed with the
current directory and used in the search algorithm above. (On Windows, the
current directory is always implicitly the first item in PATH, so
find-executable-path checks the current directory first on Windows.)

14.2.2 Files

(file-exists? path) → boolean?
  path : path-string?
Returns #t if a file (not a directory) path exists, #f otherwise.

On Windows, file-exists? reports #t for all variations of the special filenames
(e.g., "LPT1", "x:/baddir/LPT1").

(link-exists? path) → boolean?
  path : path-string?
Returns #t if a link path exists (Unix and Mac OS X), #f otherwise.

The predicates file-exists? or directory-exists? work on the final destination
of a link or series of links, while link-exists? only follows links to resolve
the base part of path (i.e., everything except the last name in the path).

This procedure never raises the exn:fail:filesystem exception.

(delete-file path) → void?
  path : path-string?
Deletes the file with path path if it exists, otherwise the exn:fail:filesystem
exception is raised. If path is a link, the link is deleted rather than the
destination of the link.

(rename-file-or-directory    old                 
                             new                 
                           [ exists-ok?])   →   void?
  old : path-string?
  new : path-string?
  exists-ok? : any/c = #f
Renames the file or directory with path old—if it exists—to the path new. If
the file or directory is not renamed successfully, the exn:fail:filesystem
exception is raised.

This procedure can be used to move a file/directory to a different directory
(on the same disk) as well as rename a file/directory within a directory.
Unless exists-ok? is provided as a true value, new cannot refer to an existing
file or directory. Even if exists-ok? is true, new cannot refer to an existing
file when old is a directory, and vice versa.

If new exists and is replaced, the replacement is atomic on Unix and Mac OS X,
but it is not guaranteed to be atomic on Windows. Furthermore, if new exists
and is opened by any process for reading or writing, then attempting to replace
it will typically fail on Windows.

If old is a link, the link is renamed rather than the destination of the link,
and it counts as a file for replacing any existing new.

(file-or-directory-modify-seconds    path                
                                   [ secs-n              
                                     fail-thunk])   →   any
  path : path-string?
  secs-n : (or/c exact-integer? #f) = #f
   fail-thunk   :   (-> any)
                =   (lambda () (raise (make-exn:fail:filesystem ....)))
Returns the file or directory’s last modification date as platform-specific
seconds (see also Time) when secs-n is not provided or is #f. (For FAT
filesystems on Windows, directories do not have modification dates. Therefore,
the creation date is returned for a directory, but the modification date is
returned for a file.)

If secs-n is provided and not #f, the access and modification times of path are
set to the given time.

On error (e.g., if no such file exists), fail-thunk is called, and the default
fail-thunk raises exn:fail:filesystem.

(file-or-directory-permissions path [mode])
 → (listof (or/c 'read 'write 'execute))
  path : path-string?
  mode : #f = #f
(file-or-directory-permissions path mode) → (integer-in 0 65535)
  path : path-string?
  mode : 'bits
(file-or-directory-permissions path mode) → void
  path : path-string?
  mode : (integer-in 0 65535)
When given one argument or #f as the second argument, returns a list containing
'read, 'write, and/or 'execute to indicate permission the given file or
directory path by the current user and group. On Unix and Mac OS X, permissions
are checked for the current effective user instead of the real user.

If 'bits is supplied as the second argument, the result is a platform-specific
integer encoding of the file or directory properties (mostly permissions), and
the result is independent of the current user and group. The lowest nine bits
of the encoding are somewhat portable, reflecting permissions for the file or
directory’s owner, members of the file or directory’s group, or other users:

  • #o100 : owner has read permission

  • #o200 : owner has write permission

  • #o400 : owner has execute permission

  • #o010 : group has read permission

  • #o020 : group has write permission

  • #o040 : group has execute permission

  • #o001 : others have read permission

  • #o002 : others have write permission

  • #o004 : others have execute permission

See also user-read-bit, etc. On Windows, permissions from all three (owner,
group, and others) are always the same, and read and execute permission are
always available. On Unix and Mac OS X, higher bits have a platform-specific
meaning.

If an integer is supplied as the second argument, its is used as an encoding of
properties (mostly permissions) to install for the file.

In all modes, the exn:fail:filesystem exception is raised on error (e.g., if no
such file exists).

(file-or-directory-identity path [as-link?])
 → exact-positive-integer?
  path : path-string?
  as-link? : any/c = #f
Returns a number that represents the identity of path in terms of the device
and file or directory that it accesses. This function can be used to check
whether two paths correspond to the same filesystem entity under the assumption
that the path’s entity selection does not change.

If as-link? is a true value, then if path refers to a filesystem link, the
identity of the link is returned instead of the identity of the referenced file
or directory (if any).

(file-size path) → exact-nonnegative-integer?
  path : path-string?
Returns the (logical) size of the specified file in bytes. On Mac OS X, this
size excludes the resource-fork size. On error (e.g., if no such file exists),
the exn:fail:filesystem exception is raised.

(copy-file src dest) → void?
  src : path-string?
  dest : path-string?
Creates the file dest as a copy of src. If the file is not successfully copied,
the exn:fail:filesystem exception is raised. If dest already exists, the copy
will fail. File permissions are preserved in the copy. On Mac OS X, the
resource fork is also preserved in the copy. If src refers to a link, the
target of the link is copied, rather than the link itself.

(make-file-or-directory-link to path) → void?
  to : path-string?
  path : path-string?
Creates a link path to to on Unix and Mac OS X. The creation will fail if path
already exists. The to need not refer to an existing file or directory, and to
is not expanded before writing the link. If the link is not created
successfully,the exn:fail:filesystem exception is raised. On Windows, the
exn:fail:unsupported exception is raised always.

14.2.3 Directories

See also: rename-file-or-directory, file-or-directory-modify-seconds,
file-or-directory-permissions.

(current-directory) → path-string?
(current-directory path) → void?
  path : path-string?
A parameter that determines the current directory for resolving relative paths.

When the parameter procedure is called to set the current directory, the path
argument is cleansed using cleanse-path, simplified using simplify-path, and
then converted to a directory path with path->directory-path; cleansing and
simplification raise an exception if the path is ill-formed. Thus, the current
value of current-directory is always a cleansed, simplified, complete,
directory path.

The path is not checked for existence when the parameter is set.

(current-drive) → path?
Returns the current drive name Windows. For other platforms, the
exn:fail:unsupported exception is raised. The current drive is always the drive
of the current directory.

(directory-exists? path) → boolean?
  path : path-string?
Returns #t if path refers to a directory, #f otherwise.

(make-directory path) → void?
  path : path-string?
Creates a new directory with the path path. If the directory is not created
successfully, the exn:fail:filesystem exception is raised.

(delete-directory path) → void?
  path : path-string?
Deletes an existing directory with the path path. If the directory is not
deleted successfully, the exn:fail:filesystem exception is raised.

(directory-list [path]) → (listof path?)
  path : path-string? = (current-directory)


            See also the in-directory sequence constructor.

Returns a list of all files and directories in the directory specified by path.
On Windows, an element of the list may start with \\?\REL\\.

(filesystem-root-list) → (listof path?)
Returns a list of all current root directories. Obtaining this list can be
particularly slow on Windows.

14.2.4 Declaring Paths Needed at Run Time

 (require racket/runtime-path)
The bindings documented in this section are provided by the racket/runtime-path
library, not racket/base or racket.

The racket/runtime-path library provides forms for accessing files and
directories at run time using a path that are usually relative to an enclosing
source file. Unlike using collection-path, define-runtime-path exposes each
run-time path to tools like the executable and distribution creators, so that
files and directories needed at run time are carried along in a distribution.

In addition to the bindings described below, racket/runtime-path provides #
%datum in phase level 1, since string constants are often used as compile-time
expressions with define-runtime-path.

(define-runtime-path id expr)
Uses expr as both a compile-time (i.e., phase 1) expression and a run-time
(i.e., phase 0) expression. In either context, expr should produce a path, a
string that represents a path, a list of the form (list 'lib str ...+), or a
list of the form (list 'so str).

For run time, id is bound to a path that is based on the result of expr. The
path is normally computed by taking a relative path result from expr and adding
it to a path for the enclosing file (which is computed as described below).
However, tools like the executable creator can also arrange (by colluding with
racket/runtime-path) to have a different base path substituted in a generated
executable. If expr produces an absolute path, it is normally returned
directly, but again may be replaced by an executable creator. In all cases, the
executable creator preserves the relative locations of all paths. When expr
produces a relative or absolute path, then the path bound to id is always an
absolute path.

If expr produces a list of the form (list 'lib str ...+), the value bound to id
is an absolute path. The path refers to a collection-based file similar to
using the value as a module path.

If expr produces a list of the form (list 'so str), the value bound to id can
be either str or an absolute path; it is an absolute path when adding the
platform-specific shared-library extension — as produced by (system-type
'so-suffix) — and then searching in the Racket-specific shared-object library
directories (as determined by get-lib-search-dirs) locates the path. In this
way, shared-object libraries that are installed specifically for Racket get
carried along in distributions.

If expr produces a list of the form (list 'module module-path var-ref), the
value bound to id is a module path index, where module-path is treated as
relative (if it is relative) to the module that is the home of the variable
reference var-ref, where var-ref can be #f if module-path is absolute. In an
executable, the corresponding module is carried along, including all of its
dependencies.

For compile-time, the expr result is used by an executable creator—but not the
result when the containing module is compiled. Instead, expr is preserved in
the module as a compile-time expression (in the sense of begin-for-syntax).
Later, at the time that an executable is created, the compile-time portion of
the module is executed (again), and the result of expr is the file to be
included with the executable. The reason for the extra compile-time execution
is that the result of expr might be platform-dependent, so the result should
not be stored in the (platform-independent) bytecode form of the module; the
platform at executable-creation time, however, is the same as at run time for
the executable. Note that expr is still evaluated at run-time; consequently,
avoid procedures like collection-path, which depends on the source
installation, and instead use relative paths and forms like (list 'lib str
...+).

If a path is needed only on some platforms and not on others, use
define-runtime-path-list with an expr that produces an empty list on platforms
where the path is not needed.

The enclosing path for a define-runtime-path is determined as follows from the
define-runtime-path syntactic form:

  • If the form has a source module according to syntax-source-module, then the
    source location is determined by preserving the original expression as a
    syntax object, extracting its source module path at run time (again using
    syntax-source-module), and then resolving the resulting module path index.

  • If the expression has no source module, the syntax-source location
    associated with the form is used, if is a string or path.

  • If no source module is available, and syntax-source produces no path, then
    current-load-relative-directory is used if it is not #f. Finally,
    current-directory is used if all else fails.

In the latter two cases, the path is normally preserved in (platform-specific)
byte form. If it is is within the result of find-collects-dir, however, it the
path is recorded relative to (find-collects-dir), and it is reconstructed using
(find-collects-dir) at run time.

Examples:

    ; Access a file "data.txt" at run-time that is originally
    ; located in the same directory as the module source file:
    (define-runtime-path data-file "data.txt")
    (define (read-data)
      (with-input-from-file data-file
        (lambda ()
          (read-bytes (file-size data-file)))))
     
    ; Load a platform-specific shared object (using ffi-lib)
    ; that is located in a platform-specific sub-directory of the
    ; module's source directory:
    (define-runtime-path libfit-path
      (build-path "compiled" "native" (system-library-subpath #f)
                  (path-replace-suffix "libfit"
                                       (system-type 'so-suffix))))
    (define libfit (ffi-lib libfit-path))
     
    ; Load a platform-specific shared object that might be installed
    ; as part of the operating system, or might be installed
    ; specifically for Racket:
    (define-runtime-path libssl-so
      (case (system-type)
        [(windows) '(so "ssleay32")]
        [else '(so "libssl")]))
    (define libssl (ffi-lib libssl-so))

(define-runtime-paths (id ...) expr)
Like define-runtime-path, but declares and binds multiple paths at once. The
expr should produce as many values as ids.

(define-runtime-path-list id expr)
Like define-runtime-path, but expr should produce a list of paths.

(define-runtime-module-path-index id module-path-expr)
Similar to define-runtime-path, but id is bound to a module path index that
encapsulates the result of module-path-expr relative to the enclosing module.

Use define-runtime-module-path to bind a module path that is passed to a
reflective function like dynamic-require while also creating a module
dependency for building and distributing executables.

(define-runtime-module-path id module-path)
Similar to define-runtime-path, but id is bound to a resolved module path. The
resolved module path for id corresponds to module-path (with the same syntax as
a module path for require), which can be relative to the enclosing module.

The define-runtime-module-path-index form is usually preferred, because it
creates a weaker link to the referenced module. Unlike
define-runtime-module-path-index, the define-runtime-module-path form creates a
for-label dependency from an enclosing module to module-path. Since the
dependency is merely for-label, module-path is not instantiated or visited when
the enclosing module is instantiated or visited (unless such a dependency is
created by other requires), but the code for the referenced module is loaded
when the enclosing module is loaded.

(runtime-paths module-path)
This form is mainly for use by tools such as executable builders. It expands to
a quoted list containing the run-time paths declared by module-path, returning
the compile-time results of the declaration exprs, except that paths are
converted to byte strings. The enclosing module must require (directly or
indirectly) the module specified by module-path, which is an unquoted module
path. The resulting list does not include module paths bound through
define-runtime-module-path.

14.2.5 More File and Directory Utilities

 (require racket/file)
The bindings documented in this section are provided by the racket/file and
racket libraries, but not racket/base.

(file->string path [#:mode mode-flag]) → string?
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
Reads all characters from path and returns them as a string. The mode-flag
argument is the same as for open-input-file.

(file->bytes path [#:mode mode-flag]) → bytes?
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
Reads all characters from path and returns them as a byte string. The mode-flag
argument is the same as for open-input-file.

(file->value path [#:mode mode-flag]) → any
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
Reads a single S-expression from path using read. The mode-flag argument is the
same as for open-input-file.

(file->list path [proc #:mode mode-flag]) → (listof any/c)
  path : path-string?
  proc : (input-port? . -> . any/c) = read
  mode-flag : (or/c 'binary 'text) = 'binary
Repeatedly calls proc to consume the contents of path, until eof is produced.
The mode-flag argument is the same as for open-input-file.

(file->lines    path                           
              [ #:mode mode-flag               
                #:line-mode line-mode])   →   (listof string?)
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
   line-mode   :   (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
               =   'any
Read all characters from path, breaking them into lines. The line-mode argument
is the same as the second argument to read-line, but the default is 'any
instead of 'linefeed. The mode-flag argument is the same as for open-input-file
.

(file->bytes-lines    path                           
                    [ #:mode mode-flag               
                      #:line-mode line-mode])   →   (listof bytes?)
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
   line-mode   :   (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
               =   'any
Like file->lines, but reading bytes and collecting them into lines like
read-bytes-line.

(display-to-file    v                             
                    path                          
                  [ #:mode mode-flag              
                    #:exists exists-flag])   →   void?
  v : any/c
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
   exists-flag   :   (or/c 'error 'append 'update
                           'replace 'truncate 'truncate/replace)
                 =   'error
Uses display to print v to path. The mode-flag and exists-flag arguments are
the same as for open-output-file.

(write-to-file    v                             
                  path                          
                [ #:mode mode-flag              
                  #:exists exists-flag])   →   void?
  v : any/c
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
   exists-flag   :   (or/c 'error 'append 'update
                           'replace 'truncate 'truncate/replace)
                 =   'error
Like display-to-file, but using write instead of display.

(display-lines-to-file    lst                           
                          path                          
                        [ #:separator separator         
                          #:mode mode-flag              
                          #:exists exists-flag])   →   void?
  lst : list?
  path : path-string?
  separator : any/c = #"\n"
  mode-flag : (or/c 'binary 'text) = 'binary
   exists-flag   :   (or/c 'error 'append 'update
                           'replace 'truncate 'truncate/replace)
                 =   'error
Displays each element of lst to path, adding separator after each element. The
mode-flag and exists-flag arguments are the same as for open-output-file.

(copy-directory/files src dest) → void?
  src : path-string?
  dest : path-string?
Copies the file or directory src to dest, raising exn:fail:filesystem if the
file or directory cannot be copied, possibly because dest exists already. If
src is a directory, the copy applies recursively to the directory’s content. If
a source is a link, the target of the link is copied rather than the link
itself.

(delete-directory/files path) → void?
  path : path-string?
Deletes the file or directory specified by path, raising exn:fail:filesystem if
the file or directory cannot be deleted. If path is a directory, then
delete-directory/files is first applied to each file and directory in path
before the directory is deleted.

(find-files predicate [start-path]) → (listof path?)
  predicate : (path? . -> . any/c)
  start-path : (or/c path-string? #f) = #f
Traverses the filesystem starting at start-path and creates a list of all files
and directories for which predicate returns true. If start-path is #f, then the
traversal starts from (current-directory). In the resulting list, each
directory precedes its content.

The predicate procedure is called with a single argument for each file or
directory. If start-path is #f, the argument is a pathname string that is
relative to the current directory. Otherwise, it is a path building on
start-path. Consequently, supplying (current-directory) for start-path is
different from supplying #f, because predicate receives complete paths in the
former case and relative paths in the latter. Another difference is that
predicate is not called for the current directory when start-path is #f.

The find-files traversal follows soft links. To avoid following links, use the
more general fold-files procedure.

If start-path does not refer to an existing file or directory, then predicate
will be called exactly once with start-path as the argument.

The find-files procedure raises and exception if it encounters a directory for
which directory-list fails.

(pathlist-closure path-list) → (listof path?)
  path-list : (listof path-string?)
Given a list of paths, either absolute or relative to the current directory,
returns a list such that

  • if a nested path is given, all of its ancestors are also included in the
    result (but the same ancestor is not added twice);

  • if a path refers to directory, all of its descendants are also included in
    the result;

  • ancestor directories appear before their descendants in the result list.

(fold-files    proc                   
               init-val               
             [ start-path             
               follow-links?])   →   any
              (or/c (path? (or/c 'file 'dir 'link) any/c
   proc   :           . -> . any/c)
                    (path? (or/c 'file 'dir 'link) any/c
                      . -> . (values any/c any/c)))
  init-val : any/c
  start-path : (or/c path-string? #f) = #f
  follow-links? : any/c = #t
Traverses the filesystem starting at start-path, calling proc on each
discovered file, directory, and link. If start-path is #f, then the traversal
starts from (current-directory).

The proc procedure is called with three arguments for each file, directory, or
link:

  • If start-path is #f, the first argument is a pathname string that is
    relative to the current directory. Otherwise, the first argument is a
    pathname that starts with start-path. Consequently, supplying (
    current-directory) for start-path is different from supplying #f, because
    proc receives complete paths in the former case and relative paths in the
    latter. Another difference is that proc is not called for the current
    directory when start-path is #f.

  • The second argument is a symbol, either 'file, 'dir, or 'link. The second
    argument can be 'link when follow-links? is #f, in which case the
    filesystem traversal does not follow links. If follow-links? is #t, then
    proc will only get a 'link as a second argument when it encounters a
    dangling symbolic link (one that does not resolve to an existing file or
    directory).

  • The third argument is the accumulated result. For the first call to proc,
    the third argument is init-val. For the second call to proc (if any), the
    third argument is the result from the first call, and so on. The result of
    the last call to proc is the result of fold-files.

The proc argument is used in an analogous way to the procedure argument of
foldl, where its result is used as the new accumulated result. There is an
exception for the case of a directory (when the second argument is 'dir): in
this case the procedure may return two values, the second indicating whether
the recursive scan should include the given directory or not. If it returns a
single value, the directory is scanned. In the cases of files or links (when
the second argument is 'file or 'link), a second value is permitted but
ignored.

If the start-path is provided but no such path exists, or if paths disappear
during the scan, then an exception is raised.

(make-directory* path) → void?
  path : path-string?
Creates directory specified by path, creating intermediate directories as
necessary.

(make-temporary-file  [ template                  
                        copy-from-filename        
                        directory])          →   path?
  template : string? = "mztmp~a"
  copy-from-filename : (or/c path-string? #f 'directory) = #f
  directory : (or/c path-string? #f) = #f
Creates a new temporary file and returns a pathname string for the file.
Instead of merely generating a fresh file name, the file is actually created;
this prevents other threads or processes from picking the same temporary name.

The template argument must be a format string suitable for use with format and
one additional string argument (where the string contains only digits). If the
resulting string is a relative path, it is combined with the result of (
find-system-path 'temp-dir), unless directory is provided and non-#f, in which
case the file name generated from template is combined with directory to obtain
a full path.

If copy-from-filename is provided as path, the temporary file is created as a
copy of the named file (using copy-file). If copy-from-filename is #f, the
temporary file is created as empty. If copy-from-filename is 'directory, then
the temporary “file” is created as a directory.

When a temporary file is created, it is not opened for reading or writing when
the pathname is returned. The client program calling make-temporary-file is
expected to open the file with the desired access and flags (probably using the
'truncate flag; see open-output-file) and to delete it when it is no longer
needed.

(get-preference    name                                           
                 [ failure-thunk                                  
                   flush-mode                                     
                   filename                                       
                   #:use-lock? use-lock?                          
                   #:timeout-lock-there timeout-lock-there        
                   #:lock-there lock-there])                 →   any
  name : symbol?
  failure-thunk : (-> any) = (lambda () #f)
  flush-mode : any/c = 'timestamp
  filename : (or/c string-path? #f) = #f
  use-lock? : any/c = #t
  timeout-lock-there : (or/c (path? . -> . any) #f) = #f
   lock-there   :   (or/c (path? . -> . any) #f)
                    (make-handle-get-preference-locked
                =    0.01 name failure-thunk flush-mode filename
                     #:lock-there timeout-lock-there)
Extracts a preference value from the file designated by (find-system-path
'pref-file), or by filename if it is provided and is not #f. In the former
case, if the preference file doesn’t exist, get-preferences attempts to read an
old preferences file, and then a "racket-prefs.rktd" file in the "defaults"
collection, instead. If none of those files exists, the preference set is
empty.

The preference file should contain a symbol-keyed association list (written to
the file with the default parameter settings). Keys starting with racket:,
mzscheme:, mred:, and plt: in any letter case are reserved for use by Racket
implementers.

The result of get-preference is the value associated with name if it exists in
the association list, or the result of calling failure-thunk otherwise.

Preference settings are cached (weakly) across calls to get-preference, using (
path->complete-path filename) as a cache key. If flush-mode is provided as #f,
the cache is used instead of the re-consulting the preferences file. If
flush-mode is provided as 'timestamp (the default), then the cache is used only
if the file has a timestamp that is the same as the last time the file was
read. Otherwise, the file is re-consulted.

On platforms for which preferences-lock-file-mode returns 'file-lock and when
use-lock? is true, preference-file reading is guarded by a lock; multiple
readers can share the lock, but writers take the lock exclusively. If the
preferences file cannot be read because the lock is unavailable, lock-there is
called on the path of the lock file; if lock-there is #f, an exception is
raised. The default lock-there handler retries about 5 times (with increasing
delays between each attempt) before trying timeout-lock-there, and the default
timeout-lock-there triggers an exception.

See also put-preferences. For a more elaborate preference system, see
preferences:get.

Old preferences files: When a filename is not provided and the file indicated
by (find-system-path 'pref-file) does not exist, the following paths are
checked for compatibility with old versions of Racket:

  • Windows: (build-path (find-system-path 'pref-dir) 'up "PLT Scheme"
    "plt-prefs.ss")

  • Mac OS X: (build-path (find-system-path 'pref-dir)
    "org.plt-scheme.prefs.ss")

  • Unix: (expand-user-path "~/.plt-scheme/plt-prefs.ss")

(put-preferences    names              
                    vals               
                  [ locked-proc        
                    filename])    →   void?
  names : (listof symbol?)
  vals : list?
  locked-proc : (path? . -> . any) = (lambda (p) (error ....))
  filename : (or/c #f path-string?) = #f
Installs a set of preference values and writes all current values to the
preference file designated by (find-system-path 'pref-file), or filename if it
is supplied and not #f.

The names argument supplies the preference names, and vals must have the same
length as names. Each element of vals must be an instance of a built-in data
type whose write output is readable (i.e., the print-unreadable parameter is
set to #f while writing preferences).

Current preference values are read from the preference file before updating,
and a write lock is held starting before the file read, and lasting until after
the preferences file is updated. The lock is implemented by the existence of a
file in the same directory as the preference file; see
preferences-lock-file-mode for more information. If the directory of the
preferences file does not already exist, it is created.

If the write lock is already held, then locked-proc is called with a single
argument: the path of the lock file. The default locked-proc reports an error;
an alternative thunk might wait a while and try again, or give the user the
choice to delete the lock file (in case a previous update attempt encountered
disaster and locks are implemented by the presence of the lock file).

If filename is #f or not supplied, and the preference file does not already
exist, then values read from the "defaults" collection (if any) are written for
preferences that are not mentioned in names.

(preferences-lock-file-mode) → (or/c 'exists 'file-lock)
Reports the way that the lock file is used to implement preference-file locking
on the current platform.

The 'exists mode is currently used on all platforms except Windows. In 'exists
mode, the existence of the lock file indicates that a write lock is held, and
readers need no lock (because the preferences file is atomically updated via
rename-file-or-directory).

The 'file-lock mode is currently used on Windows. In 'file-lock mode, shared
and exclusive locks (in the sense of port-try-file-lock?) on the lock file
reflect reader and writer locks on the preference-file content. (The preference
file itself is not locked, because a lock would interfere with replacing the
file via rename-file-or-directory.)

(make-handle-get-preference-locked    delay                    
                                      name                     
                                    [ failure-thunk            
                                      flush-mode               
                                      filename                 
                                      #:lock-there lock-there  
                                      #:max-delay max-delay])  
 → (path-string? . -> . any)
  delay : real?
  name : symbol?
  failure-thunk : (-> any) = (lambda () #f)
  flush-mode : any/c = 'timestamp
  filename : (or/c path-string? #f) = #f
  lock-there : (or/c (path? . -> . any) #f) = #f
  max-delay : real? = 0.2
Creates a procedure suitable for use as the #:lock-there argument to
get-preference, where the name, failure-thunk, flush-mode, and filename are all
passed on to get-preference by the result procedure to retry the preferences
lookup.

Before calling get-preference, the result procedure uses (sleep delay) to
pause. Then, if (* 2 delay) is less than max-delay, the result procedure calls

make-handle-get-preference-locked to generate a new retry procedure to pass to
get-preference, but with a delay of (* 2 delay). If (* 2 delay) is not less
than max-delay, then get-preference is called with the given lock-there,
instead.

(call-with-file-lock/timeout    filename                       
                                kind                           
                                thunk                          
                                failure-thunk                  
                              [ #:get-lock-file get-lock-file  
                                #:delay delay                  
                                #:max-delay max-delay])        
 → any
  filename : (or/c path-string? #f)
  kind : (or/c 'shared 'exclusive)
  thunk : (-> any)
  failure-thunk : (-> any)
   get-lock-file   :   (-> path-string?)
                   =   (lambda () (make-lock-filename filename))
  delay : real? = 0.01
  max-delay : real? = 0.2
Obtains a lock for the filename returned from (get-lock-file) and then calls
thunk. When thunk returns, call-with-file-lock releases the lock, returning the
result of thunk. The call-with-file-lock/timeout function will retry after
#:delay seconds and continue retrying with exponential backoff until delay
reaches #:max-delay. If call-with-file-lock/timeout fails to obtain the lock,
failure-thunk is called in tail position. The kind argument specifies whether
the lock is 'shared or 'exclusive

The filename argument specifies a file path prefix that is only used to
generate the lock filename, when #:get-lock-file is not present. The
call-with-file-lock/timeout function uses a separate lock file to prevent race
conditions on filename, when filename has not yet been created. On the Windows
platfom, the call-with-file-lock/timeout function uses a separate lock file
("_LOCKfilename"), because a lock on filename would interfere with replacing
filename via rename-file-or-directory.

Examples:

    > (call-with-file-lock/timeout filename 'exclusive
        (lambda () (printf "File is locked\n"))
        (lambda () (printf "Failed to obtain lock for file\n")))
    File is locked

    > (call-with-file-lock/timeout #f 'exclusive
        (lambda ()
          (call-with-file-lock/timeout filename 'shared
            (lambda () (printf "Shouldn't get here\n"))
            (lambda () (printf "Failed to obtain lock for file\n"))))
        (lambda () (printf "Shouldn't ger here eithere\n"))
        #:get-lock-file (lambda () (make-lock-file-name filename)))
    Failed to obtain lock for file



(make-lock-file-name path) → path-string?
  path : path-string?
(make-lock-file-name dir name) → path-string?
  dir : path-string?
  name : path-string?
Creates a lock filename by prepending "_LOCK" on windows or ".LOCK" on all
other platforms to the file portion of the path.

Example:

    > (make-lock-file-name "/home/george/project/important-file")
    #<path:/home/george/project/.LOCKimportant-file>



user-read-bit : #o400
user-write-bit : #o200
user-execute-bit : #o100
group-read-bit : #o040
group-write-bit : #o020
group-execute-bit : #o010
other-read-bit : #o004
other-write-bit : #o002
other-execute-bit : #o001
Constants that are useful with file-or-directory-permissions and bitwise
operations such as bitwise-ior, and bitwise-and.

[...search manuals...]
  top← prev  up  next → 
 
